metavar naturals, n ::= {{ coq nat }}
metavar var, x ::= {{ repr-locally-nameless }} {{ lex alphanum }}

grammar
typ, T {{ tex \tau }} :: 'Ty_' ::=
  | num :: :: num

exp, e :: '' ::=
  | x                     :: :: var
  | num [ n ]             :: :: num
  | plus  ( e1 ; e2 )     :: :: plus
  | let   ( e1 ; x . e2 ) :: :: letdef  (+ bind x in e2 +)
  | [ e1 / x ] e2         :: M:: subst         {{ coq (open_exp_wrt_exp [[x e2]] [[e1]]) }}

substitutions
  single e   x :: subst

freevars
  e   x :: fv

grammar
ctx, G {{ tex \Gamma }} :: ''     ::= {{ com typing context }} {{ coq list ( atom * typ ) }}
  | empty          ::   :: Empty {{ coq nil }}
                                 {{ tex \bullet }}
                                 {{ com empty context }}
  | G , x : T      ::   :: Cons  {{ coq (([[x]]~[[T]])++[[G]]) }}
                                 {{ com assumption }}

terminals :: 'terminals_' ::=
  | |-                  ::   :: turnstile  {{ tex \vdash }}
  | |-->                ::   :: transition {{ tex \longmapsto }}
  | in                  ::   :: in         {{ tex \in }}
  | fv                  ::   :: fv         {{ tex \mathsf{fv}\! }}

formula :: 'formula_' ::=
  | judgement                ::   :: judgement
  % | is_value v               ::   :: is_value
  %   {{ coq is_value [[v]] }}
  | uniq G                   ::   :: uniqG
    {{ coq uniq [[G]] }}
	  {{ tex \mathsf{uniq}[[G]] }}
  | x : T in G               ::   :: inG
    {{ coq binds [[x]][[T]][[G]] }}
  | x notin fv e             ::   :: fresh
    {{ coq [[x]] \notin fv[[e]] }}
  | x notin dom G            ::   :: notInGx
    {{ coq ~ AtomSetImpl.In [[x]] (dom [[G]]) }}
  | n1 + n2 = n3           :: :: sum
    {{ coq Nat.add [[n1]] [[n2]] = [[n3]] }}

embed
{{ coq

Module StlcNotations.
Notation "[ z ~> u ] e" := (subst_exp u z e) (at level 0).
Notation open e1 e2     := (open_exp_wrt_exp e1 e2).
Notation "e ^ x"        := (open_exp_wrt_exp e (var_f x)).
End StlcNotations.
}}

defns
Jstatics :: '' ::=

 defn
 G |- e : T :: ::typing::'T_' by

    uniq G
    x : T in G
    ---------- :: 41a
    G |- x : T

    ----------------- :: 41c
    G |- num[n] : num

    G |- e1 : num
    G |- e2 : num
    ---------------------- :: 41d
    G |- plus(e1;e2) : num

    G |- e1 : T1
    G, x : T1 |- e2 : T2
    ----------------------- :: 41h
    G |- let(e1; x.e2) : T2

defns
Jop :: '' ::=

  defn
  e val :: :: is_value :: v_ {{ com Values }} by

    ---------- :: 53a
    num[n] val

  defn
  e |--> e' :: :: trans :: tr_ {{ com Transitions }} by

    n1 + n2 = n
    ---------------------------------- :: 54a
    plus(num[n1]; num[n2]) |--> num[n]

    e1 |--> e1'
    ------------------------------- :: 54b
    plus(e1; e2) |--> plus(e1'; e2)

    e1 val
    e2 |--> e2'
    ------------------------------- :: 54c
    plus(e1; e2) |--> plus(e1; e2')

    e1 |--> e1'
    --------------------------------- :: 54g
    let(e1; x.e2) |--> let(e1'; x.e2)

    e1 val
    --------------------------- :: 54h
    let(e1; x.e2) |--> [e1/x]e2
